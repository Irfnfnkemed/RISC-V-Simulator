# RISC-V-Simulator
## 示意图
![](https://notes.sjtu.edu.cn/uploads/upload_247bc3aa68d2c25d83e327bfae9e4851.jpg)


## 过程
1. 各个模块执行
2. 用修改缓存覆盖当前数据；

## 具体模块执行
### Reorder Buffer
若队尾可发射，结合RF中依赖关系、寄存器的值以及ROB中已经ready的指令(未提交)的结果，将其发射至RS中，其中LUI，AUIPC，JAL直接在ROB中进行运算。同时，根据RF情况，添加RF缓冲区中的依赖关系。特别的，若为内存load/store指令，将占位指令发送至LSB缓冲区中以保证顺序执行。

若队头可提交，提交队头，将其从ROB中删去。若其为内存写指令，加入LSB缓冲区；其他情况，根据依赖关系以及寄存器编号，更改RF中相应的依赖关系与相应的值(注意寄存器依赖关系已被后来的指令覆盖，但仍需根据寄存器编号修改相应值的特殊情况；注意在提交删去依赖关系的同时有发射指令增加同一寄存器的依赖关系的特殊情况)，删去RS中的依赖关系(注意在提交时同时有指令发射至RS的特殊情况)。特别的，若为JALR，修改PC缓冲区的PC指向，并在下周期恢复PC的正常状态。


特别的，若提交的分支指令跳转预测错误，清空ROB,RS,Decoder,RF中的依赖关系,LSB中除了已经经过RS的Load指令外的其他指令。设置PC为清除状态，并设置PC缓冲区至正确的指向(周期末将执行相应的清除操作，并清除PC的所有异常状态)。修改对应的局部二位饱和计数器。

若队列未满，从Decoder中拉取一条指令，加入到队尾中；否则，设置PC、Decoder为冻结状态(持续一周期)。

### Reservation Station
检查RS，将无依赖关系的指令加入ALU进行运算。

对于算完的指令，若为内存读指令，将其加入LSB缓冲区中；其他，将运算结果存入ROB的修改缓冲区，同时将ROB修改缓冲区的对应指令的状态改为ready。将算完的指令从RS中删去。

### Load/Store Buffer
执行队列队头已经经过RS的Load/Store操作。完成指令后，弹出队列。

若完成Load指令，将其返回至ROB缓冲区中。

### Decoder
从内存中读取指令并进行解码，存入缓冲区中。

特别的，若读到JAL指令，设置PC指向缓冲区；若读到JALR指令，设置下周期PC为停止状态(一直持续直至JALR提交)；若读到分支指令，根据对应的局部饱和计数器决定是否跳转，并相应地修改PC指向缓冲区。

### PC
默认每个周期偏移量为4。若为冻结状态，一周期停止PC移动；若为停止状态，一直停止PC移动直至状态解除；若为清除状态， 清除各模块与PC异常状态。

## 代码实现总览
![](https://notes.sjtu.edu.cn/uploads/upload_6d1c6474ced36e278b67dcf293147d89.png)

